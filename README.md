# Cplus

Cplus is an educational experiment over the C language. We “re‑edit” C by adding a minimal `class` syntax and keep everything else as plain C23. No templates and no complex machinery — the goal is to show “what happens under the hood”.

Core idea
- Parse `class` syntax and transpile it to readable C:
  - `class Foo { int x; int f(int n); };`
  - becomes
    - `typedef struct Foo Foo;`
    - `struct Foo { int x; };`
    - `int Foo_f(int n);`

Design principles
- Output must compile as strict C (C23).
- No hidden `self`: if you want object context, write `Foo *self` explicitly.
- Keep everything explicit and reversible for didactic purposes.

What works now
- C‑like grammar with `class` integrated as a first‑class type (like `struct`).
- Class body accepts fields and method prototypes (statements require `;`, like C).
- Optional access modifiers per member: `public` and `private` (at most one). They are stripped during generation; access rules can be checked in a later pass.
- Trailing declarators after the class body (C style): `class Foo { ... } *p, v;` → `struct Foo *p, v;`
- Function parameter parsing is permissive (balanced parentheses), so pointer parameters and similar C forms are accepted (e.g., `int *p`, `Foo *self`).
- `typedef` support for prototypes and declarations (including `typedef` names used in return types and parameters).
- Everything that is not `class` is echoed unchanged (preprocessor lines, C declarations/definitions).

Not implemented yet (by design for this checkpoint)
- `interface`, inheritance, and vtables (planned next).
- Access‑rule enforcement (today we just parse/strip modifiers; semantic checks are a future step).

Quick start
1) Build the parser
   - `make -C parser`
2) Try inline parsing
   - `./parser/parser -x "class Foo { private int x; int f(int n); };"`
   - Output (example):
     ```c
     typedef struct Foo Foo;
     struct Foo {
         int x;
     };
     int Foo_f(int n);
     ```
3) C‑like trailing declarators
   - `./parser/parser -x "class Bar { int k; void g(void); } *p, v;"`
   - Output:
     ```c
     typedef struct Bar Bar;
     struct Bar {
         int k;
     };
     struct Bar *p, v;
     void Bar_g(void);
     ```

Repository layout
- `docs/grammar.mpc` — C‑like grammar with `class` and permissive parameter lists
- `gen_parser/` — generator that produces a self‑contained parser from the grammar
- `parser/` — generated parser + simple AST‑to‑C transformer
- `tests/` — examples and legacy specs (not fully aligned with this checkpoint)

Notes
- Generation is minimal on purpose. We only desugar `class` and keep the rest of the C code as is.
- Identifiers and comments generated by the tool are in English.
- See `docs/cplus_specs.md` for the long‑term vision (interfaces, inheritance, RTTI, etc.).

## Usage

- Build the generator and parser (clean + build)
  - Generate the standalone parser source from the grammar and compile everything:
    ```sh
    # 1) Build the grammar generator
    make -C gen_parser clean && make -C gen_parser

    # 2) Regenerate the parser source from docs/grammar.mpc
    ./gen_parser/gen_parser docs/grammar.mpc > parser/src/main.c

    # 3) Build the parser
    make -C parser clean && make -C parser
    ```
  - If you only changed transformer code (`parser/src/*.c`) and not the grammar, you can just:
    ```sh
    make -C parser
    ```

- Parse inline source (prints transformed C to stdout)
  - `./parser/parser -x "class Foo { private int x; int f(int n); };"`

- Parse a file
  - `./parser/parser -f path/to/source.cplus.h`

- Print the embedded grammar (for debugging)
  - `./parser/parser -G`

- Generate a new parser from a different grammar file (advanced)
  - `./gen_parser/gen_parser path/to/your.mpc > parser/src/main.c && make -C parser`

- Examples
  - Class with trailing declarator
    - `./parser/parser -x "class Foo { int x; void f(int n); } foo;"`
  - Pointers and explicit self
    - `./parser/parser -x "class Motor { int start(Motor *self); void stop(void); };"`
  - Typedef and prototypes
    - `./parser/parser -x "typedef int I; I f(I *p);"`

- Save output to a file (then compile with any C23 compiler)
  - `./parser/parser -x "class Foo { int x; int f(int n); };" > out.c`
  - `gcc -std=c23 -Wall -Wextra -o app out.c`

## Test Suite

- Script: `./do_tests.sh`
- Usage:
  ```sh
  ./do_tests.sh            # run both passed and failed suites
  ./do_tests.sh -p         # only passed
  ./do_tests.sh -f         # only failed
  ./do_tests.sh -p -f      # explicitly both
  ./do_tests.sh -o out.txt # redirect all output (stdout+stderr) to file
  ./do_tests.sh -h         # help
  ```
  The script feeds files from `tests/passed/` and `tests/failed/` to `parser/parser` and prints whether each one parses successfully (or fails when it should).

## Baseline

The project still keeps a historical “baseline” tag representing the state where the original grammar, parser, and tests were synchronized. The current checkpoint evolves the grammar and transformer toward a C‑first, didactic pipeline.
