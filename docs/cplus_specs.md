# Cplus Summary Specification

## Objective
Minimal extension of C23 to enable object-oriented programming.  

Transpiles to pure C that is readable and compilable by any C23 compiler.  

Prioritizes composition and aggregation over inheritance.  

Single inheritance (only one base) + multiple interfaces.  

Encapsulation is enforced at the transpiler level — the generated C code exposes everything, but rules are checked in Cplus.  

## Reserved Keywords

### class
Defines a class. Does not interfere with the standard C `struct`. To declare a class in Cplus you use `class` and not `struct`.  

**Basic syntax:**
```java
class Foo {
    // members declaration
}
```

### interface
Defines an interface. An `interface` only has public methods, therefore it does not allow other modifiers.  

**Basic syntax:**
```java
interface IFoo {
    // methods declaration
}
```

### public, protected, private
Access modifiers for members.  

**Basic syntax:**
```cpp
class Foo {
    public int f1(Foo *self);
    protected char *getStr(Foo *self);
    private char *msg;
}
```

### extends
Used to define the base class in case of inheritance.  

**Basic syntax:**
```java
class Foo extends Bar {
    // members declaration
}
```

### implements
Used to define the set of interfaces implemented by a class.  

**Basic syntax:**
```java
class Foo implements IClone, IBar {
    // members declaration
}
```

### as
Used for static _casting_.  

**Basic syntax:**
```java
auto c = obj as IClone;
```

### new, del
Keywords for allocation and deallocation. 

---

# Basic Syntax Rules

See grammar.mpc

OBS:

* Grammars must be generated without comment

* The gen_parse tool can generate the main.c parser with must parse any source code from Cplus that respect the grammar


---

# Rules

* A class that implements an interface must provide all implementations.  

* Visibility:  
  * `public` → accessible by any code.  
  * `protected` → accessible by the class itself and its subclasses.  
  * `private` → accessible only by the class itself.  

* Interfaces:  
  * only `public`.  
  * two interfaces with the same method name must have identical full signatures.  
  * a class implementing two interfaces with the same method only needs to provide one implementation.  
  * only one entry in the vtable.  
  * one vtable per class.  

* Inheritance:  
  * Single inheritance only: one `extends`.  
  * Layout: base is the first field of the derived class (compatible with upcast by pointer).  
  * Automatic override: base `public/protected` methods with the same signature in the derived class overwrite in the vtable.  

* Members:  
  * Instance members: stored in each object.  
  * Class members (`static`): stored globally, not in the class instance.  

* Methods:  
  * Normal → direct C calls.  
  * Virtual → vtable function pointers.  
  * By default, methods are virtual (for simplicity).  

* Overloading:  
  * Still under evaluation.  

---

# Object Creation and Destruction

**Heap:**
```cpp
Motor *m = new(Motor, 5000);
del(m);
```

**Generates:**
```cpp
Motor *cplus_new(ClassMeta *meta, ...);

void cplus_del(void *obj);
```

**Stack:**
```cpp
Motor m;
init(&m, 5000);
deinit(&m);
```

---

# Initialization

Two levels:

* `sys_init()` / `sys_deinit()` → generated by the transpiler (sets vtables, overrides, meta).  
* `init()` / `deinit()` → user-defined, automatically call sys_* in prologue/epilogue.  

---

# RTTI & Meta

Each class generates a `ClassMeta` object:  

```cpp
typedef struct {
    const char *name;
    size_t size;
    const ClassMeta *base;
    // vtables per interface and class
} ClassMeta;
```

Used by `cplus_new()` and safe casts (`as`).  
The transpiler injects meta information into instances in the `Class` field.  

---

# Casts

Class → interface:
```cpp
IStartable *ist = m as IStartable;
```

Derived class → base:
```cpp
Device *d = m as Device;
```

Checked by the transpiler; generated C just performs a simple cast.  

---

# Files and Separation

* `.h` → `class` + method declarations.  
* `.cp` → implementations.  

Allows composition of multiple files following standard C practices.  

---

# C Code Generation

* All visibilities become public structs in C.  
* Encapsulation is guaranteed by the transpiler, not at runtime. 
  * The programmer can be use of opaque types to enable real encapsulation in C, but he/she needs use heap allocation/deallocation
* Virtual methods → vtable function pointers.  
* `#line` used to map _errors/warnings_ to `.cplus` sources.  
  * Forward: real line in `.cplus`.  
  * Backward: `#line 1 "Class.gen.c"`.  

---

# Conventions

**Generated C naming:**  
* `Class_method` for normal methods.  
* `Class__sys_init`, `Class__sys_deinit` are generated automatically.  
* Virtual methods in the vtable use fixed signatures for the class. 

---

# Generics
Cplus have simple generics.

**Syntax:**
```java
List<int> list;   // creates a list of ints

```

Generated code:

```c
List_int list;    //creates a list of ints
```

