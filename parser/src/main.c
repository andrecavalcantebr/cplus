/*
    FILE: parser_generated.c
    DESCR: Self-contained Cplus parser (MPC/mpca_lang) with CLI
            -G : print grammar
            -f : parse file
            -x : parse string
    AUTHOR: Generated by gen_parser
    DATE: August, 2025
    LICENSE: CC BY-SA
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <mpc.h>
#include "ast.h"

/* ============== Utility: read entire file ============== */
static char *slurp(const char *path, size_t *out_len) {
    FILE *f = fopen(path, "rb");
    if (!f) { fprintf(stderr, "Error opening file: %s (%s)\n", path, strerror(errno)); return NULL; }
    if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, "Error seeking file: %s\n", path); fclose(f); return NULL; }
    long n = ftell(f);
    if (n < 0) { fprintf(stderr, "Error telling file size: %s\n", path); fclose(f); return NULL; }
    rewind(f);
    char *buf = (char *)malloc((size_t)n + 1);
    if (!buf) { fprintf(stderr, "Out of memory reading: %s\n", path); fclose(f); return NULL; }
    size_t rd = fread(buf, 1, (size_t)n, f);
    fclose(f);
    buf[rd] = '\0';
    if (out_len) *out_len = rd;
    return buf;
}

static const char *GRAMMAR =
  "program           : /^/ <decl>* /$/ ;\n"
  "decl              : <interface> | <class> | <c_chunk> ;\n"
  "\n"
  "identifier        : /[A-Za-z_][A-Za-z0-9_]*/ ;\n"
  "\n"
  "type_name         : <identifier> <generic_args_opt> <ptr_suffix> ;\n"
  "generic_args_opt  : (\"<\" <type_list> \">\")? ;\n"
  "type_list         : <type_name> (\",\" <type_name>)* ;\n"
  "ptr_suffix        : (\"*\")* ;\n"
  "\n"
  "param_list        : (<param> (\",\" <param>)*)? ;\n"
  "param             : <type_name> <identifier> ;\n"
  "\n"
  "interface         : \"interface\" <identifier> \"{\" <interface_item>* \"}\" (\";\")? ;\n"
  "interface_item    : <method_sig> \";\" | <c_comment> ;\n"
  "method_sig        : <type_name> <identifier> \"(\" <param_list> \")\" ;\n"
  "\n"
  "class             : \"class\" <identifier> <class_tail> \"{\" <class_item>* \"}\" (\";\")? ;\n"
  "class_tail        : (\"extends\" <identifier>)? (\"implements\" <ident_list>)? ;\n"
  "ident_list        : <identifier> (\",\" <identifier>)* ;\n"
  "\n"
  "class_item        : <member_decl> | <c_comment> | <c_pp_line> ;\n"
  "member_decl       : <access_mods_opt> <type_name> <identifier> <member_after_name> ;\n"
  "access_mods_opt   : (<access_kw>)* ;\n"
  "access_kw         : \"public\" | \"protected\" | \"private\" ;\n"
  "\n"
  "member_after_name : \"(\" <param_list> \")\" \";\"\n"
  "                  | \";\" ;\n"
  "\n"
  "c_pp_line         : /#[^\\n]*/ ;\n"
  "c_line_comment    : /\\/\\/[^\\n]*/ ;\n"
  "c_block_comment   : /\\/\\*([^*]|\\*+[^*\\/])*\\*+\\// ;\n"
  "c_comment         : <c_line_comment> | <c_block_comment> ;\n"
  "c_decl_like       : /[^;{}]+[;{}]/ ;\n"
  "c_chunk           : <c_pp_line> | <c_comment> | <c_decl_like> ;\n"
;

/* ============== Parser rules ============== */
static mpc_parser_t *program;
static mpc_parser_t *decl;
static mpc_parser_t *identifier;
static mpc_parser_t *type_name;
static mpc_parser_t *generic_args_opt;
static mpc_parser_t *type_list;
static mpc_parser_t *ptr_suffix;
static mpc_parser_t *param_list;
static mpc_parser_t *param;
static mpc_parser_t *interface;
static mpc_parser_t *interface_item;
static mpc_parser_t *method_sig;
static mpc_parser_t *class;
static mpc_parser_t *class_tail;
static mpc_parser_t *ident_list;
static mpc_parser_t *class_item;
static mpc_parser_t *member_decl;
static mpc_parser_t *access_mods_opt;
static mpc_parser_t *access_kw;
static mpc_parser_t *member_after_name;
static mpc_parser_t *c_pp_line;
static mpc_parser_t *c_line_comment;
static mpc_parser_t *c_block_comment;
static mpc_parser_t *c_comment;
static mpc_parser_t *c_decl_like;
static mpc_parser_t *c_chunk;

static void usage(const char *argv0) {
    fprintf(stderr,
        "Usage:\n"
        "  %s -G\n"
        "  %s -f <input.cplus[.h]>\n"
        "  %s -x \"<source>\"\n"
        "\n"
        "Options:\n"
        "  -G          Print the embedded grammar and exit\n"
        "  -f <path>   Parse the given Cplus header/source file\n"
        "  -x <text>   Parse the given text directly\n",
        argv0, argv0, argv0);
}

static int build_all_parsers(void) {
    program = mpc_new("program");
    decl = mpc_new("decl");
    identifier = mpc_new("identifier");
    type_name = mpc_new("type_name");
    generic_args_opt = mpc_new("generic_args_opt");
    type_list = mpc_new("type_list");
    ptr_suffix = mpc_new("ptr_suffix");
    param_list = mpc_new("param_list");
    param = mpc_new("param");
    interface = mpc_new("interface");
    interface_item = mpc_new("interface_item");
    method_sig = mpc_new("method_sig");
    class = mpc_new("class");
    class_tail = mpc_new("class_tail");
    ident_list = mpc_new("ident_list");
    class_item = mpc_new("class_item");
    member_decl = mpc_new("member_decl");
    access_mods_opt = mpc_new("access_mods_opt");
    access_kw = mpc_new("access_kw");
    member_after_name = mpc_new("member_after_name");
    c_pp_line = mpc_new("c_pp_line");
    c_line_comment = mpc_new("c_line_comment");
    c_block_comment = mpc_new("c_block_comment");
    c_comment = mpc_new("c_comment");
    c_decl_like = mpc_new("c_decl_like");
    c_chunk = mpc_new("c_chunk");
    /* mpca_lang returns mpc_err_t* (NULL on success) */
    mpc_err_t *err = mpca_lang(MPCA_LANG_DEFAULT, GRAMMAR,
        program,
        decl,
        identifier,
        type_name,
        generic_args_opt,
        type_list,
        ptr_suffix,
        param_list,
        param,
        interface,
        interface_item,
        method_sig,
        class,
        class_tail,
        ident_list,
        class_item,
        member_decl,
        access_mods_opt,
        access_kw,
        member_after_name,
        c_pp_line,
        c_line_comment,
        c_block_comment,
        c_comment,
        c_decl_like,
        c_chunk,
        NULL);
    if (err) { mpc_err_print(err); mpc_err_delete(err); return 0; }
    return 1;
}

static void cleanup_all_parsers(void) {
    mpc_cleanup(26, program
, decl
, identifier
, type_name
, generic_args_opt
, type_list
, ptr_suffix
, param_list
, param
, interface
, interface_item
, method_sig
, class
, class_tail
, ident_list
, class_item
, member_decl
, access_mods_opt
, access_kw
, member_after_name
, c_pp_line
, c_line_comment
, c_block_comment
, c_comment
, c_decl_like
, c_chunk
);
}

static int parse_source(const char *input_name, const char *source) {
    mpc_result_t r;
    if (mpc_parse(input_name, source, program, &r)) {
        puts("== PARSE SUCCESS ==");
        // print_program(r.output);
        mpc_ast_print(r.output);
        mpc_ast_delete(r.output);
        return 0;
    } else {
        fprintf(stderr, "== PARSE ERROR ==\n");
        mpc_err_print(r.error);
        mpc_err_delete(r.error);
        return 1;
    }
}

int main(int argc, char **argv) {
    const char *file_path = NULL;
    const char *expr_text = NULL;
    int print_grammar = 0;

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-G") == 0) {
            print_grammar = 1;
        } else if (strcmp(argv[i], "-f") == 0) {
            if (i + 1 >= argc) { usage(argv[0]); return 2; }
            file_path = argv[++i];
        } else if (strcmp(argv[i], "-x") == 0) {
            if (i + 1 >= argc) { usage(argv[0]); return 2; }
            expr_text = argv[++i];
        } else {
            usage(argv[0]);
            return 2;
        }
    }

    if (print_grammar + (file_path != NULL) + (expr_text != NULL) != 1) {
        usage(argv[0]);
        return 2;
    }

    if (print_grammar) { fputs(GRAMMAR, stdout); return 0; }

    if (!build_all_parsers()) { cleanup_all_parsers(); return 4; }

    int rc = 0;
    if (file_path) {
        size_t src_len = 0;
        char *src = slurp(file_path, &src_len);
        if (!src) { fprintf(stderr, "Failed to read input file: %s\n", file_path); cleanup_all_parsers(); return 5; }
        rc = parse_source(file_path, src);
        free(src);
    } else if (expr_text) {
        rc = parse_source("<cmdline>", expr_text);
    }

    cleanup_all_parsers();
    return rc;
}
