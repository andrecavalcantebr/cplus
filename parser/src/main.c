/*
    FILE: parser_generated.c
    DESCR: Self-contained Cplus parser (MPC/mpca_lang) with CLI
            -G : print grammar (with # comments)
            -f : parse file
            -x : parse string
    AUTHOR: Generated by gen_parser
    DATE: September, 2025
    LICENSE: CC BY-SA
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <mpc.h>
#include "ast.h"

/* ============== Utility: read entire file ============== */
static char *slurp(const char *path, size_t *out_len) {
    FILE *f = fopen(path, "rb");
    if (!f) { fprintf(stderr, "Error opening file: %s (%s)\n", path, strerror(errno)); return NULL; }
    if (fseek(f, 0, SEEK_END) != 0) { fprintf(stderr, "Error seeking file: %s\n", path); fclose(f); return NULL; }
    long n = ftell(f);
    if (n < 0) { fprintf(stderr, "Error telling file size: %s\n", path); fclose(f); return NULL; }
    rewind(f);
    char *buf = (char *)malloc((size_t)n + 1);
    if (!buf) { fprintf(stderr, "Out of memory reading: %s\n", path); fclose(f); return NULL; }
    size_t rd = fread(buf, 1, (size_t)n, f);
    fclose(f);
    buf[rd] = '\0';
    if (out_len) *out_len = rd;
    return buf;
}

static const char *GRAMMAR_RAW =
  "#######################################################################\n"
  "# C-like grammar with Cplus 'class' integrated as a C type\n"
  "# - Accepts ordinary C decls/funcs/preprocessor\n"
  "# - Adds 'class' as a type introducer (like 'struct') and 'class' declarations\n"
  "# - Class body allows fields and method prototypes (no definitions)\n"
  "#######################################################################\n"
  "\n"
  "# ---------- Lexical ----------\n"
  "ws             : /[ \\t\\r\\n]+/ ;\n"
  "line_comment   : /\\/\\/[^\\n]*/ ;\n"
  "block_comment  : /\\/\\*([^*]|\\*+[^*\\/])*\\*+\\// ;\n"
  "comment        : <line_comment> | <block_comment> ;\n"
  "skips          : (<ws> | <comment>)* ;\n"
  "\n"
  "ident          : /[A-Za-z_][A-Za-z0-9_]*/ ;\n"
  "number         : /0[xX][0-9A-Fa-f]+/ | /[0-9]+(\\.[0-9]*)?([eE][\\+\\-]?[0-9]+)?/ ;\n"
  "char_lit       : /'([^'\\\\]|\\\\.)'/ ;\n"
  "str_lit        : /\\\"([^\\\"\\\\]|\\\\.)*\\\"/ ;\n"
  "\n"
  "pp_line        : /#[^\\n]*/ ;\n"
  "\n"
  "lparen         : \"(\" ;\n"
  "rparen         : \")\" ;\n"
  "lbrace         : \"{\" ;\n"
  "rbrace         : \"}\" ;\n"
  "lbrack         : \"[\" ;\n"
  "rbrack         : \"]\" ;\n"
  "comma          : \",\" ;\n"
  "semi           : \";\" ;\n"
  "colon          : \":\" ;\n"
  "\n"
  "# ---------- Minimal expressions/statements (enough for function bodies) ----------\n"
  "assign_op_tok  : \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \"&=\" | \"^=\" | \"|=\" ;\n"
  "\n"
  "op_infix_mul   : \"*\" | \"/\" | \"%\" ;\n"
  "op_infix_add   : \"+\" | \"-\" ;\n"
  "op_infix_shift : \"<<\" | \">>\" ;\n"
  "op_infix_rel   : \"<\" | \">\" | \"<=\" | \">=\" ;\n"
  "op_infix_eq    : \"==\" | \"!=\" ;\n"
  "op_infix_band  : \"&\" ;\n"
  "op_infix_bxor  : \"^\" ;\n"
  "op_infix_bor   : \"|\" ;\n"
  "op_infix_land  : \"&&\" ;\n"
  "op_infix_lor   : \"||\" ;\n"
  "\n"
  "op_prefix      : \"++\" | \"--\" | \"!\" | \"~\" | \"+\" | \"-\" | \"*\" | \"&\" ;\n"
  "op_postfix     : \"++\" | \"--\" ;\n"
  "\n"
  "kw_return      : \"return\" ;\n"
  "\n"
  "primary        : <skips> ( <ident> | <number> | <char_lit> | <str_lit> | <lparen> <skips> <expr> <skips> <rparen> ) ;\n"
  "arglist_opt    : ( <arglist> )? ;\n"
  "arglist        : <skips> <assign> ( <skips> <comma> <skips> <assign> )* ;\n"
  "postfix_core   : <primary>\n"
  "                 ( <skips> <lparen> <skips> <arglist_opt> <skips> <rparen>\n"
  "                 | <skips> <lbrack> <skips> <expr> <skips> <rbrack>\n"
  "                 | <skips> \".\" <skips> <ident>\n"
  "                 | <skips> \"->\" <skips> <ident>\n"
  "                 )* ;\n"
  "postfix        : <postfix_core> ( <skips> <op_postfix> )* ;\n"
  "unary          : ( <skips> <op_prefix> )+ <skips> <unary> | <postfix> ;\n"
  "mul            : <unary> ( <skips> <op_infix_mul> <skips> <unary> )* ;\n"
  "add            : <mul>   ( <skips> <op_infix_add> <skips> <mul>   )* ;\n"
  "shift          : <add>   ( <skips> <op_infix_shift> <skips> <add> )* ;\n"
  "rel            : <shift> ( <skips> <op_infix_rel>   <skips> <shift> )* ;\n"
  "eq             : <rel>   ( <skips> <op_infix_eq>    <skips> <rel>   )* ;\n"
  "band           : <eq>    ( <skips> <op_infix_band>  <skips> <eq>    )* ;\n"
  "bxor           : <band>  ( <skips> <op_infix_bxor>  <skips> <band>  )* ;\n"
  "bor            : <bxor>  ( <skips> <op_infix_bor>   <skips> <bxor>  )* ;\n"
  "land           : <bor>   ( <skips> <op_infix_land>  <skips> <bor>   )* ;\n"
  "lor            : <land>  ( <skips> <op_infix_lor>   <skips> <land>  )* ;\n"
  "\n"
  "assign         : ( <skips> <postfix_core> <skips> <assign_op_tok> <skips> <assign> ) | <lor> ;\n"
  "expr           : <assign> ( <skips> <comma> <skips> <assign> )* ;\n"
  "\n"
  "compound       : <skips> <lbrace> <skips> ( <stmt> )* <skips> <rbrace> ;\n"
  "stmt           : <skips> <semi>\n"
  "               | <skips> <kw_return> <skips> ( <expr> )? <skips> <semi>\n"
  "               | <skips> <expr> <skips> <semi>\n"
  "               | <compound> ;\n"
  "\n"
  "# ---------- Raw balanced (for permissive function prototypes) ----------\n"
  "raw_block      : <lbrace> <raw_inside>* <rbrace> ;\n"
  "raw_paren      : <lparen> <raw_inside>* <rparen> ;\n"
  "raw_inside     : <raw_block>\n"
  "               | <raw_paren>\n"
  "               | <str_lit>\n"
  "               | <char_lit>\n"
  "               | <comment>\n"
  "               | /[^{}()\\\"'\\/]+/\n"
  "               | \"/\" ;\n"
  "\n"
  "# ---------- Types & declarators ----------\n"
  "kw_void        : \"void\" ;\n"
  "kw_char        : \"char\" ;\n"
  "kw_short       : \"short\" ;\n"
  "kw_int         : \"int\" ;\n"
  "kw_long        : \"long\" ;\n"
  "kw_float       : \"float\" ;\n"
  "kw_double      : \"double\" ;\n"
  "kw_signed      : \"signed\" ;\n"
  "kw_unsigned    : \"unsigned\" ;\n"
  "kw_struct      : \"struct\" ;\n"
  "kw_class       : \"class\" ;\n"
  "kw_extern      : \"extern\" ;\n"
  "kw_typedef     : \"typedef\" ;\n"
  "kw_public      : \"public\" ;\n"
  "kw_private     : \"private\" ;\n"
  "\n"
  "type_qualifier : \"const\" | \"volatile\" | \"restrict\" ;\n"
  "qualifiers     : ( <type_qualifier> <skips> )+ ;\n"
  "\n"
  "pointer        : ( \"*\" ( <skips> ( <qualifiers> <skips> )? )? )+ ;\n"
  "\n"
  "class_type     : <kw_class> <skips> <ident> ;\n"
  "struct_type    : <kw_struct> <skips> <ident> ;\n"
  "\n"
  "type_kw        : <kw_void> | <kw_char> | <kw_short> | <kw_int> | <kw_long> | <kw_float> | <kw_double> | <kw_signed> | <kw_unsigned> | <kw_extern> ;\n"
  "type_ident_no_paren   : <ident> !( <skips> <lparen> ) ;\n"
  "type_spec_atom        : <type_kw> | <class_type> | <struct_type> | <type_ident_no_paren> ;\n"
  "type_spec_atom_noid   : <kw_void> | <kw_char> | <kw_short> | <kw_int> | <kw_long> | <kw_float> | <kw_double> | <kw_signed> | <kw_unsigned> | <class_type> | <struct_type> ;\n"
  "type_spec             : <skips> ( <type_spec_atom> <skips> )+ ;\n"
  "type_spec_no_ident    : <skips> ( <type_spec_atom_noid> <skips> )+ ;\n"
  "\n"
  "# For raw function prototypes, be specific to avoid swallowing the function name\n"
  "type_spec_basic       : <skips> ( <type_spec_atom_noid> <skips> )+ ;\n"
  "typedef_type_name     : <type_ident_no_paren> ;\n"
  "type_spec_for_proto   : <type_spec_basic>\n"
  "                      | <typedef_type_name> ;\n"
  "\n"
  "declarator     : <skips> ( <pointer> <skips> )? <direct_decl> ;\n"
  "paren_content_any : /[^)]*/ ;\n"
  "\n"
  "direct_decl    : <skips> ( <ident>\n"
  "                 | <pointer> <skips> <ident>\n"
  "                 | <lparen> <skips> <declarator> <skips> <rparen> )\n"
  "                 ( <skips> <lparen> <skips> <paren_content_any> <rparen>\n"
  "                 | <skips> <lbrack> <skips> ( <expr> )? <skips> <rbrack>\n"
  "                 )* ;\n"
  "\n"
  "param_decl     : <skips> <type_spec> ( <skips> \"*\" )* <skips> <ident>\n"
  "               | <skips> <type_spec> <skips> <declarator> ;\n"
  "param_list     : <skips> <param_decl> ( <skips> <comma> <skips> <param_decl> )* ;\n"
  "\n"
  "initializer    : <skips> \"=\" <skips> <expr> ;\n"
  "init_decl      : <skips> <declarator> <skips> ( <initializer> )? ;\n"
  "\n"
  "c_decl         : <skips> <type_spec> <skips> <init_decl> ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "c_funcdef      : <skips> <type_spec> <skips> <declarator> <skips> <compound> ;\n"
  "typedef_decl   : <skips> <kw_typedef> <skips> <type_spec_no_ident> <skips> <init_decl>\n"
  "                 ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "c_funcproto_raw: <skips> <type_spec_for_proto> <skips> <ident> <skips> <raw_paren> <skips> <semi> ;\n"
  "# prototype using typedef-name as the only type token (fallback)\n"
  "c_funcproto_two_ident: <skips> <ident> <skips> <ident> <skips> <raw_paren> <skips> <semi> ;\n"
  "\n"
  "# ---------- Class declaration ----------\n"
  "access_opt          : ( <skips> ( <kw_public> | <kw_private> ) <skips> )? ;\n"
  "class_field_decl    : <skips> <access_opt> <type_spec> <skips> <init_decl>\n"
  "                      ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "class_method_decl   : <skips> <access_opt> <type_spec> <skips> <ident> <skips>\n"
  "                      <lparen> <skips> /[^)]*/ <rparen> <skips> <semi> ;\n"
  "class_body_item    : <skips> ( <class_method_decl> | <class_field_decl> | <pp_line> ) ;\n"
  "class_header       : <skips> <kw_class> <skips> <ident> <skips> ;\n"
  "class_decl         : <class_header> <lbrace> <skips> ( <class_body_item> )* <skips> <rbrace>\n"
  "                     <skips> ( <init_decl> ( <skips> <comma> <skips> <init_decl> )* )? <skips> <semi> ;\n"
  "forward_class      : <skips> <kw_class> <skips> <ident> <skips> <semi> ;\n"
  "\n"
  "# ---------- Top-level ----------\n"
  "top_item       : <skips> ( <class_decl>\n"
  "                         | <forward_class>\n"
  "                         | <pp_line>\n"
  "                         | <c_funcproto_raw>\n"
  "                         | <c_funcproto_two_ident>\n"
  "                         | <typedef_decl>\n"
  "                         | <c_funcdef>\n"
  "                         | <c_decl>\n"
  "                         | <stmt>\n"
  "                         ) ;\n"
  "\n"
  "unit           : <skips> ( <top_item> )* ;\n"
  "program        : /^/ <unit> /$/ ;\n"
;

static const char *GRAMMAR =
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "ws             : /[ \\t\\r\\n]+/ ;\n"
  "line_comment   : /\\/\\/[^\\n]*/ ;\n"
  "block_comment  : /\\/\\*([^*]|\\*+[^*\\/])*\\*+\\// ;\n"
  "comment        : <line_comment> | <block_comment> ;\n"
  "skips          : (<ws> | <comment>)* ;\n"
  "\n"
  "ident          : /[A-Za-z_][A-Za-z0-9_]*/ ;\n"
  "number         : /0[xX][0-9A-Fa-f]+/ | /[0-9]+(\\.[0-9]*)?([eE][\\+\\-]?[0-9]+)?/ ;\n"
  "char_lit       : /'([^'\\\\]|\\\\.)'/ ;\n"
  "str_lit        : /\\\"([^\\\"\\\\]|\\\\.)*\\\"/ ;\n"
  "\n"
  "pp_line        : /#[^\\n]*/ ;\n"
  "\n"
  "lparen         : \"(\" ;\n"
  "rparen         : \")\" ;\n"
  "lbrace         : \"{\" ;\n"
  "rbrace         : \"}\" ;\n"
  "lbrack         : \"[\" ;\n"
  "rbrack         : \"]\" ;\n"
  "comma          : \",\" ;\n"
  "semi           : \";\" ;\n"
  "colon          : \":\" ;\n"
  "\n"
  "\n"
  "assign_op_tok  : \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \"&=\" | \"^=\" | \"|=\" ;\n"
  "\n"
  "op_infix_mul   : \"*\" | \"/\" | \"%\" ;\n"
  "op_infix_add   : \"+\" | \"-\" ;\n"
  "op_infix_shift : \"<<\" | \">>\" ;\n"
  "op_infix_rel   : \"<\" | \">\" | \"<=\" | \">=\" ;\n"
  "op_infix_eq    : \"==\" | \"!=\" ;\n"
  "op_infix_band  : \"&\" ;\n"
  "op_infix_bxor  : \"^\" ;\n"
  "op_infix_bor   : \"|\" ;\n"
  "op_infix_land  : \"&&\" ;\n"
  "op_infix_lor   : \"||\" ;\n"
  "\n"
  "op_prefix      : \"++\" | \"--\" | \"!\" | \"~\" | \"+\" | \"-\" | \"*\" | \"&\" ;\n"
  "op_postfix     : \"++\" | \"--\" ;\n"
  "\n"
  "kw_return      : \"return\" ;\n"
  "\n"
  "primary        : <skips> ( <ident> | <number> | <char_lit> | <str_lit> | <lparen> <skips> <expr> <skips> <rparen> ) ;\n"
  "arglist_opt    : ( <arglist> )? ;\n"
  "arglist        : <skips> <assign> ( <skips> <comma> <skips> <assign> )* ;\n"
  "postfix_core   : <primary>\n"
  "                 ( <skips> <lparen> <skips> <arglist_opt> <skips> <rparen>\n"
  "                 | <skips> <lbrack> <skips> <expr> <skips> <rbrack>\n"
  "                 | <skips> \".\" <skips> <ident>\n"
  "                 | <skips> \"->\" <skips> <ident>\n"
  "                 )* ;\n"
  "postfix        : <postfix_core> ( <skips> <op_postfix> )* ;\n"
  "unary          : ( <skips> <op_prefix> )+ <skips> <unary> | <postfix> ;\n"
  "mul            : <unary> ( <skips> <op_infix_mul> <skips> <unary> )* ;\n"
  "add            : <mul>   ( <skips> <op_infix_add> <skips> <mul>   )* ;\n"
  "shift          : <add>   ( <skips> <op_infix_shift> <skips> <add> )* ;\n"
  "rel            : <shift> ( <skips> <op_infix_rel>   <skips> <shift> )* ;\n"
  "eq             : <rel>   ( <skips> <op_infix_eq>    <skips> <rel>   )* ;\n"
  "band           : <eq>    ( <skips> <op_infix_band>  <skips> <eq>    )* ;\n"
  "bxor           : <band>  ( <skips> <op_infix_bxor>  <skips> <band>  )* ;\n"
  "bor            : <bxor>  ( <skips> <op_infix_bor>   <skips> <bxor>  )* ;\n"
  "land           : <bor>   ( <skips> <op_infix_land>  <skips> <bor>   )* ;\n"
  "lor            : <land>  ( <skips> <op_infix_lor>   <skips> <land>  )* ;\n"
  "\n"
  "assign         : ( <skips> <postfix_core> <skips> <assign_op_tok> <skips> <assign> ) | <lor> ;\n"
  "expr           : <assign> ( <skips> <comma> <skips> <assign> )* ;\n"
  "\n"
  "compound       : <skips> <lbrace> <skips> ( <stmt> )* <skips> <rbrace> ;\n"
  "stmt           : <skips> <semi>\n"
  "               | <skips> <kw_return> <skips> ( <expr> )? <skips> <semi>\n"
  "               | <skips> <expr> <skips> <semi>\n"
  "               | <compound> ;\n"
  "\n"
  "\n"
  "raw_block      : <lbrace> <raw_inside>* <rbrace> ;\n"
  "raw_paren      : <lparen> <raw_inside>* <rparen> ;\n"
  "raw_inside     : <raw_block>\n"
  "               | <raw_paren>\n"
  "               | <str_lit>\n"
  "               | <char_lit>\n"
  "               | <comment>\n"
  "               | /[^{}()\\\"'\\/]+/\n"
  "               | \"/\" ;\n"
  "\n"
  "\n"
  "kw_void        : \"void\" ;\n"
  "kw_char        : \"char\" ;\n"
  "kw_short       : \"short\" ;\n"
  "kw_int         : \"int\" ;\n"
  "kw_long        : \"long\" ;\n"
  "kw_float       : \"float\" ;\n"
  "kw_double      : \"double\" ;\n"
  "kw_signed      : \"signed\" ;\n"
  "kw_unsigned    : \"unsigned\" ;\n"
  "kw_struct      : \"struct\" ;\n"
  "kw_class       : \"class\" ;\n"
  "kw_extern      : \"extern\" ;\n"
  "kw_typedef     : \"typedef\" ;\n"
  "kw_public      : \"public\" ;\n"
  "kw_private     : \"private\" ;\n"
  "\n"
  "type_qualifier : \"const\" | \"volatile\" | \"restrict\" ;\n"
  "qualifiers     : ( <type_qualifier> <skips> )+ ;\n"
  "\n"
  "pointer        : ( \"*\" ( <skips> ( <qualifiers> <skips> )? )? )+ ;\n"
  "\n"
  "class_type     : <kw_class> <skips> <ident> ;\n"
  "struct_type    : <kw_struct> <skips> <ident> ;\n"
  "\n"
  "type_kw        : <kw_void> | <kw_char> | <kw_short> | <kw_int> | <kw_long> | <kw_float> | <kw_double> | <kw_signed> | <kw_unsigned> | <kw_extern> ;\n"
  "type_ident_no_paren   : <ident> !( <skips> <lparen> ) ;\n"
  "type_spec_atom        : <type_kw> | <class_type> | <struct_type> | <type_ident_no_paren> ;\n"
  "type_spec_atom_noid   : <kw_void> | <kw_char> | <kw_short> | <kw_int> | <kw_long> | <kw_float> | <kw_double> | <kw_signed> | <kw_unsigned> | <class_type> | <struct_type> ;\n"
  "type_spec             : <skips> ( <type_spec_atom> <skips> )+ ;\n"
  "type_spec_no_ident    : <skips> ( <type_spec_atom_noid> <skips> )+ ;\n"
  "\n"
  "\n"
  "type_spec_basic       : <skips> ( <type_spec_atom_noid> <skips> )+ ;\n"
  "typedef_type_name     : <type_ident_no_paren> ;\n"
  "type_spec_for_proto   : <type_spec_basic>\n"
  "                      | <typedef_type_name> ;\n"
  "\n"
  "declarator     : <skips> ( <pointer> <skips> )? <direct_decl> ;\n"
  "paren_content_any : /[^)]*/ ;\n"
  "\n"
  "direct_decl    : <skips> ( <ident>\n"
  "                 | <pointer> <skips> <ident>\n"
  "                 | <lparen> <skips> <declarator> <skips> <rparen> )\n"
  "                 ( <skips> <lparen> <skips> <paren_content_any> <rparen>\n"
  "                 | <skips> <lbrack> <skips> ( <expr> )? <skips> <rbrack>\n"
  "                 )* ;\n"
  "\n"
  "param_decl     : <skips> <type_spec> ( <skips> \"*\" )* <skips> <ident>\n"
  "               | <skips> <type_spec> <skips> <declarator> ;\n"
  "param_list     : <skips> <param_decl> ( <skips> <comma> <skips> <param_decl> )* ;\n"
  "\n"
  "initializer    : <skips> \"=\" <skips> <expr> ;\n"
  "init_decl      : <skips> <declarator> <skips> ( <initializer> )? ;\n"
  "\n"
  "c_decl         : <skips> <type_spec> <skips> <init_decl> ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "c_funcdef      : <skips> <type_spec> <skips> <declarator> <skips> <compound> ;\n"
  "typedef_decl   : <skips> <kw_typedef> <skips> <type_spec_no_ident> <skips> <init_decl>\n"
  "                 ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "c_funcproto_raw: <skips> <type_spec_for_proto> <skips> <ident> <skips> <raw_paren> <skips> <semi> ;\n"
  "\n"
  "c_funcproto_two_ident: <skips> <ident> <skips> <ident> <skips> <raw_paren> <skips> <semi> ;\n"
  "\n"
  "\n"
  "access_opt          : ( <skips> ( <kw_public> | <kw_private> ) <skips> )? ;\n"
  "class_field_decl    : <skips> <access_opt> <type_spec> <skips> <init_decl>\n"
  "                      ( <skips> <comma> <skips> <init_decl> )* <skips> <semi> ;\n"
  "class_method_decl   : <skips> <access_opt> <type_spec> <skips> <ident> <skips>\n"
  "                      <lparen> <skips> /[^)]*/ <rparen> <skips> <semi> ;\n"
  "class_body_item    : <skips> ( <class_method_decl> | <class_field_decl> | <pp_line> ) ;\n"
  "class_header       : <skips> <kw_class> <skips> <ident> <skips> ;\n"
  "class_decl         : <class_header> <lbrace> <skips> ( <class_body_item> )* <skips> <rbrace>\n"
  "                     <skips> ( <init_decl> ( <skips> <comma> <skips> <init_decl> )* )? <skips> <semi> ;\n"
  "forward_class      : <skips> <kw_class> <skips> <ident> <skips> <semi> ;\n"
  "\n"
  "\n"
  "top_item       : <skips> ( <class_decl>\n"
  "                         | <forward_class>\n"
  "                         | <pp_line>\n"
  "                         | <c_funcproto_raw>\n"
  "                         | <c_funcproto_two_ident>\n"
  "                         | <typedef_decl>\n"
  "                         | <c_funcdef>\n"
  "                         | <c_decl>\n"
  "                         | <stmt>\n"
  "                         ) ;\n"
  "\n"
  "unit           : <skips> ( <top_item> )* ;\n"
  "program        : /^/ <unit> /$/ ;\n"
;

/* ============== Parser rules ============== */
static mpc_parser_t *ws;
static mpc_parser_t *line_comment;
static mpc_parser_t *block_comment;
static mpc_parser_t *comment;
static mpc_parser_t *skips;
static mpc_parser_t *ident;
static mpc_parser_t *number;
static mpc_parser_t *char_lit;
static mpc_parser_t *str_lit;
static mpc_parser_t *pp_line;
static mpc_parser_t *lparen;
static mpc_parser_t *rparen;
static mpc_parser_t *lbrace;
static mpc_parser_t *rbrace;
static mpc_parser_t *lbrack;
static mpc_parser_t *rbrack;
static mpc_parser_t *comma;
static mpc_parser_t *semi;
static mpc_parser_t *colon;
static mpc_parser_t *assign_op_tok;
static mpc_parser_t *op_infix_mul;
static mpc_parser_t *op_infix_add;
static mpc_parser_t *op_infix_shift;
static mpc_parser_t *op_infix_rel;
static mpc_parser_t *op_infix_eq;
static mpc_parser_t *op_infix_band;
static mpc_parser_t *op_infix_bxor;
static mpc_parser_t *op_infix_bor;
static mpc_parser_t *op_infix_land;
static mpc_parser_t *op_infix_lor;
static mpc_parser_t *op_prefix;
static mpc_parser_t *op_postfix;
static mpc_parser_t *kw_return;
static mpc_parser_t *primary;
static mpc_parser_t *arglist_opt;
static mpc_parser_t *arglist;
static mpc_parser_t *postfix_core;
static mpc_parser_t *postfix;
static mpc_parser_t *unary;
static mpc_parser_t *mul;
static mpc_parser_t *add;
static mpc_parser_t *shift;
static mpc_parser_t *rel;
static mpc_parser_t *eq;
static mpc_parser_t *band;
static mpc_parser_t *bxor;
static mpc_parser_t *bor;
static mpc_parser_t *land;
static mpc_parser_t *lor;
static mpc_parser_t *assign;
static mpc_parser_t *expr;
static mpc_parser_t *compound;
static mpc_parser_t *stmt;
static mpc_parser_t *raw_block;
static mpc_parser_t *raw_paren;
static mpc_parser_t *raw_inside;
static mpc_parser_t *kw_void;
static mpc_parser_t *kw_char;
static mpc_parser_t *kw_short;
static mpc_parser_t *kw_int;
static mpc_parser_t *kw_long;
static mpc_parser_t *kw_float;
static mpc_parser_t *kw_double;
static mpc_parser_t *kw_signed;
static mpc_parser_t *kw_unsigned;
static mpc_parser_t *kw_struct;
static mpc_parser_t *kw_class;
static mpc_parser_t *kw_extern;
static mpc_parser_t *kw_typedef;
static mpc_parser_t *kw_public;
static mpc_parser_t *kw_private;
static mpc_parser_t *type_qualifier;
static mpc_parser_t *qualifiers;
static mpc_parser_t *pointer;
static mpc_parser_t *class_type;
static mpc_parser_t *struct_type;
static mpc_parser_t *type_kw;
static mpc_parser_t *type_ident_no_paren;
static mpc_parser_t *type_spec_atom;
static mpc_parser_t *type_spec_atom_noid;
static mpc_parser_t *type_spec;
static mpc_parser_t *type_spec_no_ident;
static mpc_parser_t *type_spec_basic;
static mpc_parser_t *typedef_type_name;
static mpc_parser_t *type_spec_for_proto;
static mpc_parser_t *declarator;
static mpc_parser_t *paren_content_any;
static mpc_parser_t *direct_decl;
static mpc_parser_t *param_decl;
static mpc_parser_t *param_list;
static mpc_parser_t *initializer;
static mpc_parser_t *init_decl;
static mpc_parser_t *c_decl;
static mpc_parser_t *c_funcdef;
static mpc_parser_t *typedef_decl;
static mpc_parser_t *c_funcproto_raw;
static mpc_parser_t *c_funcproto_two_ident;
static mpc_parser_t *access_opt;
static mpc_parser_t *class_field_decl;
static mpc_parser_t *class_method_decl;
static mpc_parser_t *class_body_item;
static mpc_parser_t *class_header;
static mpc_parser_t *class_decl;
static mpc_parser_t *forward_class;
static mpc_parser_t *top_item;
static mpc_parser_t *unit;
static mpc_parser_t *program;

static void usage(const char *argv0) {
    fprintf(stderr,
        "Usage:\n"
        "  %s -G\n"
        "  %s -f <input.cplus[.h]>\n"
        "  %s -x \"<source>\"\n"
        "\n"
        "Options:\n"
        "  -G          Print the embedded grammar (with # comments) and exit\n"
        "  -f <path>   Parse the given Cplus header/source file\n"
        "  -x <text>   Parse the given text directly\n"
        "  -d <outdir> Directory to write generated C files (default=.)\n",
        argv0, argv0, argv0);
}

static int build_all_parsers(void) {
    ws = mpc_new("ws");
    line_comment = mpc_new("line_comment");
    block_comment = mpc_new("block_comment");
    comment = mpc_new("comment");
    skips = mpc_new("skips");
    ident = mpc_new("ident");
    number = mpc_new("number");
    char_lit = mpc_new("char_lit");
    str_lit = mpc_new("str_lit");
    pp_line = mpc_new("pp_line");
    lparen = mpc_new("lparen");
    rparen = mpc_new("rparen");
    lbrace = mpc_new("lbrace");
    rbrace = mpc_new("rbrace");
    lbrack = mpc_new("lbrack");
    rbrack = mpc_new("rbrack");
    comma = mpc_new("comma");
    semi = mpc_new("semi");
    colon = mpc_new("colon");
    assign_op_tok = mpc_new("assign_op_tok");
    op_infix_mul = mpc_new("op_infix_mul");
    op_infix_add = mpc_new("op_infix_add");
    op_infix_shift = mpc_new("op_infix_shift");
    op_infix_rel = mpc_new("op_infix_rel");
    op_infix_eq = mpc_new("op_infix_eq");
    op_infix_band = mpc_new("op_infix_band");
    op_infix_bxor = mpc_new("op_infix_bxor");
    op_infix_bor = mpc_new("op_infix_bor");
    op_infix_land = mpc_new("op_infix_land");
    op_infix_lor = mpc_new("op_infix_lor");
    op_prefix = mpc_new("op_prefix");
    op_postfix = mpc_new("op_postfix");
    kw_return = mpc_new("kw_return");
    primary = mpc_new("primary");
    arglist_opt = mpc_new("arglist_opt");
    arglist = mpc_new("arglist");
    postfix_core = mpc_new("postfix_core");
    postfix = mpc_new("postfix");
    unary = mpc_new("unary");
    mul = mpc_new("mul");
    add = mpc_new("add");
    shift = mpc_new("shift");
    rel = mpc_new("rel");
    eq = mpc_new("eq");
    band = mpc_new("band");
    bxor = mpc_new("bxor");
    bor = mpc_new("bor");
    land = mpc_new("land");
    lor = mpc_new("lor");
    assign = mpc_new("assign");
    expr = mpc_new("expr");
    compound = mpc_new("compound");
    stmt = mpc_new("stmt");
    raw_block = mpc_new("raw_block");
    raw_paren = mpc_new("raw_paren");
    raw_inside = mpc_new("raw_inside");
    kw_void = mpc_new("kw_void");
    kw_char = mpc_new("kw_char");
    kw_short = mpc_new("kw_short");
    kw_int = mpc_new("kw_int");
    kw_long = mpc_new("kw_long");
    kw_float = mpc_new("kw_float");
    kw_double = mpc_new("kw_double");
    kw_signed = mpc_new("kw_signed");
    kw_unsigned = mpc_new("kw_unsigned");
    kw_struct = mpc_new("kw_struct");
    kw_class = mpc_new("kw_class");
    kw_extern = mpc_new("kw_extern");
    kw_typedef = mpc_new("kw_typedef");
    kw_public = mpc_new("kw_public");
    kw_private = mpc_new("kw_private");
    type_qualifier = mpc_new("type_qualifier");
    qualifiers = mpc_new("qualifiers");
    pointer = mpc_new("pointer");
    class_type = mpc_new("class_type");
    struct_type = mpc_new("struct_type");
    type_kw = mpc_new("type_kw");
    type_ident_no_paren = mpc_new("type_ident_no_paren");
    type_spec_atom = mpc_new("type_spec_atom");
    type_spec_atom_noid = mpc_new("type_spec_atom_noid");
    type_spec = mpc_new("type_spec");
    type_spec_no_ident = mpc_new("type_spec_no_ident");
    type_spec_basic = mpc_new("type_spec_basic");
    typedef_type_name = mpc_new("typedef_type_name");
    type_spec_for_proto = mpc_new("type_spec_for_proto");
    declarator = mpc_new("declarator");
    paren_content_any = mpc_new("paren_content_any");
    direct_decl = mpc_new("direct_decl");
    param_decl = mpc_new("param_decl");
    param_list = mpc_new("param_list");
    initializer = mpc_new("initializer");
    init_decl = mpc_new("init_decl");
    c_decl = mpc_new("c_decl");
    c_funcdef = mpc_new("c_funcdef");
    typedef_decl = mpc_new("typedef_decl");
    c_funcproto_raw = mpc_new("c_funcproto_raw");
    c_funcproto_two_ident = mpc_new("c_funcproto_two_ident");
    access_opt = mpc_new("access_opt");
    class_field_decl = mpc_new("class_field_decl");
    class_method_decl = mpc_new("class_method_decl");
    class_body_item = mpc_new("class_body_item");
    class_header = mpc_new("class_header");
    class_decl = mpc_new("class_decl");
    forward_class = mpc_new("forward_class");
    top_item = mpc_new("top_item");
    unit = mpc_new("unit");
    program = mpc_new("program");
    /* mpca_lang returns mpc_err_t* (NULL on success) */
    mpc_err_t *err = mpca_lang(MPCA_LANG_WHITESPACE_SENSITIVE, GRAMMAR,
        ws,
        line_comment,
        block_comment,
        comment,
        skips,
        ident,
        number,
        char_lit,
        str_lit,
        pp_line,
        lparen,
        rparen,
        lbrace,
        rbrace,
        lbrack,
        rbrack,
        comma,
        semi,
        colon,
        assign_op_tok,
        op_infix_mul,
        op_infix_add,
        op_infix_shift,
        op_infix_rel,
        op_infix_eq,
        op_infix_band,
        op_infix_bxor,
        op_infix_bor,
        op_infix_land,
        op_infix_lor,
        op_prefix,
        op_postfix,
        kw_return,
        primary,
        arglist_opt,
        arglist,
        postfix_core,
        postfix,
        unary,
        mul,
        add,
        shift,
        rel,
        eq,
        band,
        bxor,
        bor,
        land,
        lor,
        assign,
        expr,
        compound,
        stmt,
        raw_block,
        raw_paren,
        raw_inside,
        kw_void,
        kw_char,
        kw_short,
        kw_int,
        kw_long,
        kw_float,
        kw_double,
        kw_signed,
        kw_unsigned,
        kw_struct,
        kw_class,
        kw_extern,
        kw_typedef,
        kw_public,
        kw_private,
        type_qualifier,
        qualifiers,
        pointer,
        class_type,
        struct_type,
        type_kw,
        type_ident_no_paren,
        type_spec_atom,
        type_spec_atom_noid,
        type_spec,
        type_spec_no_ident,
        type_spec_basic,
        typedef_type_name,
        type_spec_for_proto,
        declarator,
        paren_content_any,
        direct_decl,
        param_decl,
        param_list,
        initializer,
        init_decl,
        c_decl,
        c_funcdef,
        typedef_decl,
        c_funcproto_raw,
        c_funcproto_two_ident,
        access_opt,
        class_field_decl,
        class_method_decl,
        class_body_item,
        class_header,
        class_decl,
        forward_class,
        top_item,
        unit,
        program,
        NULL);
    if (err) {
        mpc_err_print(err);
        mpc_err_delete(err);
        return 0;
    }
    return 1;
}

static void cleanup_all_parsers(void) {
    mpc_cleanup(107, ws, line_comment, block_comment, comment, skips, ident, number, char_lit, str_lit, pp_line, lparen, rparen, lbrace, rbrace, lbrack, rbrack, comma, semi, colon, assign_op_tok, op_infix_mul, op_infix_add, op_infix_shift, op_infix_rel, op_infix_eq, op_infix_band, op_infix_bxor, op_infix_bor, op_infix_land, op_infix_lor, op_prefix, op_postfix, kw_return, primary, arglist_opt, arglist, postfix_core, postfix, unary, mul, add, shift, rel, eq, band, bxor, bor, land, lor, assign, expr, compound, stmt, raw_block, raw_paren, raw_inside, kw_void, kw_char, kw_short, kw_int, kw_long, kw_float, kw_double, kw_signed, kw_unsigned, kw_struct, kw_class, kw_extern, kw_typedef, kw_public, kw_private, type_qualifier, qualifiers, pointer, class_type, struct_type, type_kw, type_ident_no_paren, type_spec_atom, type_spec_atom_noid, type_spec, type_spec_no_ident, type_spec_basic, typedef_type_name, type_spec_for_proto, declarator, paren_content_any, direct_decl, param_decl, param_list, initializer, init_decl, c_decl, c_funcdef, typedef_decl, c_funcproto_raw, c_funcproto_two_ident, access_opt, class_field_decl, class_method_decl, class_body_item, class_header, class_decl, forward_class, top_item, unit, program);
}

static int parse_source(const char *input_name, const char *source, const char *output_dir) {
    mpc_result_t r;
    if (mpc_parse(input_name, source, program, &r)) {
        puts("== PARSE SUCCESS ==");
        ast_transformation(r.output, output_dir);
        mpc_ast_delete(r.output);
        return 0;
    } else {
        fprintf(stderr, "== PARSE ERROR ==\n");
        mpc_err_print(r.error);
        mpc_err_delete(r.error);
        return 1;
    }
}

int main(int argc, char **argv) {
    const char *file_path = NULL;
    const char *expr_text = NULL;
    const char *output_dir = ".";
    int print_grammar = 0;

    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-G") == 0) {
            print_grammar = 1;
        } else if (strcmp(argv[i], "-f") == 0) {
            if (i + 1 >= argc) { usage(argv[0]); return 2; }
            file_path = argv[++i];
        } else if (strcmp(argv[i], "-x") == 0) {
            if (i + 1 >= argc) { usage(argv[0]); return 2; }
            expr_text = argv[++i];
        } else if (strcmp(argv[i], "-d") == 0) {
            if (i + 1 >= argc) { usage(argv[0]); return 2; }
            output_dir = argv[++i];
        } else {
            usage(argv[0]);
            return 2;
        }
    }

    if (print_grammar + (file_path != NULL) + (expr_text != NULL) != 1) {
        usage(argv[0]);
        return 2;
    }

    if (print_grammar) { fputs(GRAMMAR_RAW, stdout); return 0; }

    if (!build_all_parsers()) {
        cleanup_all_parsers();
        return 4;
    }

    int rc = 0;
    if (file_path) {
        size_t src_len = 0;
        char *src = slurp(file_path, &src_len);
        if (!src) {
            fprintf(stderr, "Failed to read input file: %s\n", file_path);
            cleanup_all_parsers();
            return 5;
        }
        rc = parse_source(file_path, src, output_dir);
        free(src);
    } else if (expr_text) {
        rc = parse_source("<cmdline>", expr_text, output_dir);
    }

    cleanup_all_parsers();
    return rc;
}
