/*
    FILE: ast_dump.c
    DESCR: Printing of the AST
    AUTHOR: Andre Cavalcante
    DATE: August, 2025
    LICENSE: CC BY-SA
*/

#include "ast.h"
#include <stdio.h>
#include <stdlib.h>

static const char *acc_str(Access a)
{
    switch (a)
    {
    case ACC_PUBLIC:
        return "public";
    case ACC_PROTECTED:
        return "protected";
    default:
        return "private";
    }
}

void module_dump(const Module *m)
{
    printf("\n== Interfaces (%zu) ==\n", m->nifaces);
    for (size_t i = 0; i < m->nifaces; i++)
    {
        const Interface *I = &m->ifaces[i];
        printf("interface %s {\n", I->name);
        for (size_t k = 0; k < I->nmethods; k++)
        {
            const Method *me = &I->methods[k];
            printf("    %s %s(", me->ret_type, me->name);
            for (size_t p = 0; p < me->nparams; p++)
            {
                printf("%s %s%s", me->params[p].type, me->params[p].name,
                       (p + 1 < me->nparams) ? ", " : "");
            }
            printf(");\n");
        }
        printf("};\n\n");
    }

    printf("== Classes (%zu) ==\n", m->nclasses);
    for (size_t i = 0; i < m->nclasses; i++)
    {
        const Class *C = &m->classes[i];
        printf("class %s", C->name);
        if (C->base)
            printf(" extends %s", C->base);
        if (C->nifaces)
        {
            printf(" implements ");
            for (size_t j = 0; j < C->nifaces; j++)
            {
                printf("%s%s", C->ifaces[j], (j + 1 < C->nifaces) ? ", " : "");
            }
        }
        printf(" {\n");

        for (size_t f = 0; f < C->nfields; f++)
        {
            const Field *fl = &C->fields[f];
            printf("    %s: %s %s;\n", acc_str(fl->access), fl->type, fl->name);
        }
        for (size_t k = 0; k < C->nmethods; k++)
        {
            const Method *me = &C->methods[k];
            printf("    %s: %s %s(", acc_str(me->access), me->ret_type, me->name);
            for (size_t p = 0; p < me->nparams; p++)
            {
                printf("%s %s%s", me->params[p].type, me->params[p].name,
                       (p + 1 < me->nparams) ? ", " : "");
            }
            printf(");\n");
        }
        printf("};\n\n");
    }
}

void module_free(Module *m)
{
    /* MVP: minimal free; in production you must free strings/arrays correctly */
    (void)m;
}

// pretty printing AST
/*
    FILE: ast_pretty.c (to be inlined into main.c generated by gen_parser)
    DESCR: Funções utilitárias para imprimir AST do MPC em formato legível (Cplus)
    AUTHOR: Andre Cavalcante
    DATE: August, 2025
    LICENSE: CC BY-SA
*/

#include <stdbool.h>
#include <ctype.h>

/* ========= util: testes de tag ========= */
static bool has_tag(const mpc_ast_t *n, const char *tag)
{
    return n && n->tag && strstr(n->tag, tag) != NULL;
}

/* ========= util: coleta de texto (concatena folhas) ========= */
static void collect_text_rec(const mpc_ast_t *n, char *buf, size_t cap)
{
    if (!n || !buf || cap == 0)
        return;
    if (n->children == 0)
    {
        /* Folha: se tem contents visível (regex ou string), anexa */
        if (n->contents && *n->contents)
        {
            /* p.ex. "void", "public", "X", "{", "}" */
            strncat(buf, n->contents, cap - strlen(buf) - 1);
        }
        return;
    }
    for (int i = 0; i < n->children_num; i++)
    {
        collect_text_rec(n->children[i], buf, cap);
    }
}

/* Extrai “texto lógico” de um nó (útil p/ identifier, type simples etc.) */
static void node_text(const mpc_ast_t *n, char *out, size_t cap)
{
    out[0] = '\0';
    collect_text_rec(n, out, cap);
    /* compacta espaços múltiplos */
    size_t w = 0;
    for (size_t r = 0; out[r] && w + 1 < cap; r++)
    {
        if (isspace((unsigned char)out[r]))
        {
            if (w && out[w - 1] != ' ')
                out[w++] = ' ';
        }
        else
        {
            out[w++] = out[r];
        }
    }
    out[w] = '\0';
}

/* ========= util: busca de filhos ========= */
static const mpc_ast_t *first_child_tag(const mpc_ast_t *n, const char *tag)
{
    if (!n)
        return NULL;
    for (int i = 0; i < n->children_num; i++)
    {
        if (has_tag(n->children[i], tag))
            return n->children[i];
    }
    return NULL;
}

/* ========= impressão com indent ========= */
static void put_indent(int level)
{
    for (int i = 0; i < level; i++)
        fputs("  ", stdout);
}

/* ========= impressão de “type” (simples; já funciona c/ genéricos nível 1) ========= */
static void print_type(const mpc_ast_t *type, int level)
{
    if (!type)
        return;
    char tbuf[256];
    node_text(type, tbuf, sizeof tbuf);
    put_indent(level);
    printf("Type: %s\n", *tbuf ? tbuf : "<anon>");
}

/* ========= parâmetros ========= */
static void print_param(const mpc_ast_t *param, int level)
{
    if (!param)
        return;
    const mpc_ast_t *ptype = first_child_tag(param, "type");
    const mpc_ast_t *pname = first_child_tag(param, "identifier");
    char nbuf[128] = {0};
    if (pname)
        node_text(pname, nbuf, sizeof nbuf);

    put_indent(level);
    printf("Param: ");
    if (ptype)
        print_type(ptype, -1); /* imprime inline */
    else
        printf("Type: <unknown>\n");
    if (level >= 0)
    { /* alinhamento quando inline */
        if (ptype)
        { /* reposiciona cursor para completar linha c/ nome */
            /* nada: já saiu uma linha se print_type usou \n;
               se quiser tudo em uma linha, troque a estratégia: */
        }
    }
    if (*nbuf)
    {
        put_indent(level + 1);
        printf("Name: %s\n", nbuf);
    }
}

static void print_param_list(const mpc_ast_t *plist, int level)
{
    if (!plist)
        return;
    /* param_list := param ( , param )* — no AST os <param> aparecem direto */
    for (int i = 0; i < plist->children_num; i++)
    {
        const mpc_ast_t *c = plist->children[i];
        if (has_tag(c, "param"))
            print_param(c, level);
    }
}

/* ========= métodos ========= */
static void print_method(const mpc_ast_t *m, int level)
{
    if (!m)
        return;
    const mpc_ast_t *ret = first_child_tag(m, "type");
    const mpc_ast_t *name = first_child_tag(m, "method_name");
    const mpc_ast_t *id = name ? first_child_tag(name, "identifier") : NULL;
    const mpc_ast_t *plist = first_child_tag(m, "param_list");
    if (!plist)
        plist = first_child_tag(m, "param_list_opt"); /* compat */

    char nbuf[128] = {0};
    if (id)
        node_text(id, nbuf, sizeof nbuf);

    put_indent(level);
    printf("Method %s\n", *nbuf ? nbuf : "<anon>");

    if (ret)
    {
        put_indent(level + 1);
        printf("Return ");
        print_type(ret, level + 2);
    }
    if (plist)
    {
        put_indent(level + 1);
        puts("Params");
        print_param_list(plist, level + 2);
    }
}

/* ========= campos ========= */
static void print_field(const mpc_ast_t *f, int level)
{
    const mpc_ast_t *ft = first_child_tag(f, "type");
    const mpc_ast_t *fid = first_child_tag(f, "identifier");
    char nbuf[128] = {0};
    if (fid)
        node_text(fid, nbuf, sizeof nbuf);

    put_indent(level);
    printf("Field %s\n", *nbuf ? nbuf : "<anon>");
    if (ft)
    {
        put_indent(level + 1);
        print_type(ft, level + 1);
    }
}

/* ========= membro (método | campo) ========= */
static void print_member(const mpc_ast_t *m, int level)
{
    if (has_tag(m, "method_decl"))
    {
        print_method(m, level);
        return;
    }
    if (has_tag(m, "field_decl"))
    {
        print_field(m, level);
        return;
    }
    /* Fallback: tenta heurística (gramática antiga só tinha method_decl) */
    if (first_child_tag(m, "method_name") || first_child_tag(m, "lparen"))
    {
        print_method(m, level);
    }
}

/* ========= seção de acesso ========= */
static void print_section(const mpc_ast_t *sec, int level)
{
    if (!sec)
        return;
    const mpc_ast_t *ak = first_child_tag(sec, "access_kw");
    char akbuf[32] = {0};
    if (ak)
        node_text(ak, akbuf, sizeof akbuf);

    put_indent(level);
    printf("Section %s\n", *akbuf ? akbuf : "<access>");

    /* membros dentro da seção */
    for (int i = 0; i < sec->children_num; i++)
    {
        const mpc_ast_t *c = sec->children[i];
        if (has_tag(c, "member"))
            print_member(c, level + 1);
    }
}

/* ========= interface ========= */
static void print_interface(const mpc_ast_t *itf, int level)
{
    const mpc_ast_t *id = first_child_tag(itf, "identifier");
    char nbuf[128] = {0};
    if (id)
        node_text(id, nbuf, sizeof nbuf);

    put_indent(level);
    printf("Interface %s\n", *nbuf ? nbuf : "<anon>");
    for (int i = 0; i < itf->children_num; i++)
    {
        const mpc_ast_t *c = itf->children[i];
        if (has_tag(c, "method_decl"))
            print_member(c, level + 1);
        /* algumas gramáticas aceitam 'public:' opcional no topo */
        if (has_tag(c, "section"))
            print_section(c, level + 1);
    }
}

/* ========= classe ========= */
static void print_class(const mpc_ast_t *cls, int level)
{
    const mpc_ast_t *id = first_child_tag(cls, "identifier");
    char nbuf[128] = {0};
    if (id)
        node_text(id, nbuf, sizeof nbuf);

    put_indent(level);
    printf("Class %s\n", *nbuf ? nbuf : "<anon>");

    for (int i = 0; i < cls->children_num; i++)
    {
        const mpc_ast_t *c = cls->children[i];
        if (has_tag(c, "section"))
        {
            print_section(c, level + 1);
        }
        else if (has_tag(c, "member"))
        {
            /* membros “soltos” (sem seção explícita) */
            print_member(c, level + 1);
        }
    }
}

/* ========= programa ========= */
void print_program(const mpc_ast_t *root)
{
    if (!root)
        return;
    /* dependendo de como o mpca_lang é invocado, o topo pode ser 'program'
       ou conter um nó 'program' como filho */
    const mpc_ast_t *prog = root;
    if (!has_tag(prog, "program"))
    {
        prog = first_child_tag(root, "program");
        if (!prog)
            prog = root;
    }

    puts("Program");
    for (int i = 0; i < prog->children_num; i++)
    {
        const mpc_ast_t *c = prog->children[i];
        if (has_tag(c, "interface"))
            print_interface(c, 1);
        else if (has_tag(c, "class"))
            print_class(c, 1);
        else if (has_tag(c, "section"))
            print_section(c, 1);
        else if (has_tag(c, "member"))
            print_member(c, 1);
    }
}
