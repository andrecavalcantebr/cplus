/*
    FILE: main.c
    DESCR: Driver do parser — read a .h Cplus and prints the AST
    AUTHOR: Andre Cavalcante
    DATE: August, 2025
    LICENSE: CC BY-SA
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <mpc.h>

#include "ast.h"

/* parser declaration */
Module parse_cplus(const char *input);

static char* slurp(const char *path){
    FILE *f=fopen(path,"rb"); 
    if(!f) return NULL;
    fseek(f,0,SEEK_END); 
    long n=ftell(f); 
    rewind(f);
    char *buf=malloc((size_t)n+1);
    if(!buf) { 
        fclose(f); 
        return NULL; 
    }
    fread(buf,1,(size_t)n,f); 
    buf[n]='\0'; 
    fclose(f); 
    return buf;
}

/* Remove //... e / * ... * / , preservando quebras de linha. */
static char* strip_comments(const char *s) {
    size_t n = strlen(s), cap = n + 1;
    char *out = malloc(cap);
    if (!out) return NULL;

    enum { NORM, LINE, BLOCK } st = NORM;
    size_t i=0, o=0;
    while (i < n) {
        char c = s[i], nxt = (i+1<n ? s[i+1] : '\0');

        if (o + 2 >= cap) { cap *= 2; out = realloc(out, cap); if(!out) return NULL; }

        switch (st) {
        case NORM:
            if (c == '/' && nxt == '/') { st = LINE; i += 2; continue; }
            if (c == '/' && nxt == '*') { st = BLOCK; i += 2; continue; }
            out[o++] = c; i++; break;

        case LINE: /* // até \n */
            if (c == '\n') { out[o++] = '\n'; st = NORM; }
            i++; break;

        case BLOCK: /* até */
            if (c == '*' && nxt == '/') { st = NORM; i += 2; continue; }
            if (c == '\n') out[o++] = '\n';
            i++; break;
        }
    }
    out[o] = '\0';
    return out;
}


int main(int argc, char **argv){
    if (argc<2) { 
        fprintf(stderr, "uso: %s <arquivo.cplus.h>\n", argv[0]); 
        return 2; 
    }

    char *txt = slurp(argv[1]); 
    if(!txt) { 
        perror("slurp"); 
        return 1; 
    }

    char *clean = strip_comments(txt);
    free(txt);
    if (!clean) { 
        fprintf(stderr, "mem\n"); 
        return 1; 
    }

    Module m = parse_cplus(clean);
    module_dump(&m);
    free(clean);
    module_free(&m);
    
    return 0;
}


/* ============================================================
 * Parse for AST (Module)
 * ============================================================ */

Module parse_cplus(const char *input) {

    printf("DEBUG: %s\n", input);

    /* gramática mínima só pra testar o pipeline */
    mpc_parser_t *Ident = mpc_new("ident");
    mpc_parser_t *Iface = mpc_new("iface");
    mpc_parser_t *Top   = mpc_new("top");
    mpc_parser_t *WS    = mpc_new("ws");
    mpc_parser_t *JUNK  = mpc_new("junk");
    mpc_parser_t *TU    = mpc_new("tu");

    mpc_err_t *gerr = mpca_lang(MPCA_LANG_DEFAULT,
        " ident : /[A-Za-z_][A-Za-z0-9_]*/ ;              \n"
        " iface : \"interface\" <ident> '{' '}' ';'? ;    \n"
        " top   : <iface> ;                                \n"
        " ws    : /[ \\t\\r\\n]+/ ;                        \n"
        " junk  : <ws>+ ;                                  \n"
        " tu    : <junk>? (<top> <junk>?)* ;               \n",
    Ident, Iface, Top, WS, JUNK, TU, NULL);


    if (gerr) { mpc_err_print(gerr); mpc_err_delete(gerr); /* return */ }

    mpc_result_t r;
    if (mpc_parse("<stdin>", input, TU, &r)) {
        puts("OK min");
        mpc_ast_delete(r.output);
    } else {
        mpc_err_print(r.error);
        mpc_err_delete(r.error);
    }

    mpc_cleanup(6, Ident, Iface, Top, WS, JUNK, TU);

    Module M = {0};

    return M;
}
